import chalk from "chalk";
import fs from "fs-extra";
import url from "node:url";
import path from "path";
import sanitize from "sanitize-filename";
import { sanitizeJSON } from "./cook.js";
import LevelDatabase from "./lib/level-database.js";
import { JSONstringifyOrder, measureTime } from "./util.js";

/**
 * Unpack existing db files into json files.
 */

// Run only if this file is executed directly
const modulePath = url.fileURLToPath(import.meta.url);
if (path.resolve(modulePath) === path.resolve(process.argv[1])) {
    measureTime(async () => {
        await unpackPacks(false, {limitToPack: process.env.npm_config_pack ?? null});
    });
}

async function unpack({packName, filePath, outputDirectory, partOfCook = false}) {
    console.log(`> Starting unpack of ${packName} into ${outputDirectory}`);
    fs.mkdir(`${outputDirectory}`, { recursive: true }, (err) => {
        if (err)
            throw err;
    });

    const db = new LevelDatabase(filePath, { packName });
    const folders = await Array.fromAsync(db.getFolders());

    const folderPromises = [];

    if (folders.length) {
        const folderMap = new Map();
        const getFolderPath = (folder, parts = []) => {
            if (parts.length > 3) {
                throw (
                    `Error: Maximum folder depth exceeded for "${folder.name}" in pack: ${packName}`
                );
            }

            parts.unshift(
                sanitize(folder.name)
                    .replace(/[\s]/g, "_")
                    .replace(/[\x91\x92\u2018\u2019]/g, "'")
                    .replace(/[,;\u2122\u2026]/g, "")
                    .toLowerCase()
            );
            if (folder.folder) {
                // This folder is inside another folder
                const parent = folders.find((f) => f._id === folder.folder);
                if (!parent) {
                    throw (`Error: Unknown parent folder id [${folder.folder}] in pack: ${packName}`);
                }
                return getFolderPath(parent, parts);
            }
            parts.unshift(packName);
            return path.join(...parts);
        };

        for (const folder of folders) {
            folderMap.set(folder._id, getFolderPath(folder));
        }
        const folderFilePath = path.resolve(outputDirectory, "_folders.json");
        folderPromises.push(fs.writeFile(folderFilePath, JSONstringifyOrder(folders, 2), "utf-8"));
    }

    const itemPromises = [];
    for await (const item of db.getItems()) {
        const cleanItem = partOfCook ? item : sanitizeJSON(item);
        removeStats(cleanItem);
        const jsonOutput = JSONstringifyOrder(cleanItem, 2, "item");
        const filename = sanitize(item.name)
            .replace(/[\s]/g, "_")
            .replace(/[\x91\x92\u2018\u2019]/g, "'")
            .replace(/[,;\u2122\u2026]/g, "")
            .toLowerCase();

        const targetFile = `${outputDirectory}/${filename}.json`;
        itemPromises.push(fs.writeFile(targetFile, jsonOutput, { "flag": "w" }));

    }

    await Promise.all([...itemPromises, ...folderPromises]);
    console.log(chalk.green(`${packName} unpack complete.`));
}

export async function unpackPacks(partOfCook = false, options = {}) {
    const limitToPack = options.limitToPack ?? null;
    const sourceDir = 'dist/packs';
    console.log(chalk.blueBright(`Unpacking ${partOfCook ? "" : "and sanitizing "}all packs from ${sourceDir}`));

    if (!fs.existsSync(sourceDir)) {
        fs.mkdir(sourceDir, { recursive: true }, (err) => {
            if (err)
                throw err;
        });
    }

    const entries = await fs.opendir(sourceDir);
    const promises = [];
    for await (const folderEntry of entries) {
        if (folderEntry.isFile()) continue;
        const folder = folderEntry.name;

        if ((limitToPack
            && !folder.includes(limitToPack))
            || folder.endsWith(".db") // Skip NeDB!
        ) {
            continue;
        }

        const unpackDir = `./src/items/${folder}`;
        const packDir = `${sourceDir}/${folder}`;

        /* console.log(`> Cleaning up ${unpackDir}`);
        fs.rmdirSync(unpackDir, { recursive: true }); */

        promises.push(unpack({packName: folder, filePath: packDir, outputDirectory: unpackDir, partOfCook}));

    }

    await Promise.all(promises);
    console.log(`\nUnpack finished.\n`);

    return 0;
}

/**
 * Cleans compendium entries of the _stats property, which is generated by `cook` and thus doesn't
 * need to be stored.
 *
 * @param {Object} jsonInput An object representing the current JSON being unpacked
 */
function removeStats(jsonInput) {
    delete jsonInput._stats;
    if (jsonInput.items) {
        for (const item of jsonInput.items) {
            delete item._stats;
        }
    }
}
